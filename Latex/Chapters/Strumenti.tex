%************************************************
\chapter{Strumenti}\label{ch:strumenti}
%************************************************

Il lavoro per questa tesi è stato svolto principalmente usando un computer 
con sistema operativo GNU/Linux Ubuntu Dell Inspiron 3552 con 8 GB di RAM. 
Per lo sviluppo dei circuiti quantistici si è usato gli strumenti di 
sviluppo e di simulazione messi a disposizione dall'IBM. Questi permettono 
di progettare, simulare ed eseguire su dei quantum computer reali gli 
algoritmi scritti. Il linguaggio di programmazione, sia per l'analisi 
dei dati che per la prototipazione del circuito, è Python; grazie al 
lavoro della comunità open source questo linguaggio si è evoluto 
come strumento omnicomprensivo per una varietà sempre crescente di 
lavori di ricerca scientifica. 

\section{Qiskit}

Qiskit \cite{Qiskit} è un'interfaccia di programmazione che permette di scrivere 
circuiti quantistici e simularne l'esecuzione sul proprio computer 
o inviare un ordine di esecuzione a un vero computer quantistico tramite 
l'interfaccia offerta dall'IBM Quantum Experience. 
È consigliata l'esecuzione tramite l'interfaccia Jupyter Notebook per 
la manipolazione dei risultati in tempo reale. 

\section{IBM Q Experience}

L'IBM Q Experience è un servizio offerto gratuitamente da IBM che permette 
a chiunque di avere a che fare con un computer quantistico. Sono presenti 
risorse didattiche per imparare a scrivere il primo circuito, strumenti 
di comunità come una piattaforma di domande e risposte e soprattutto 
un sistema per creare i propri algoritmi. Si può accedere agli ordini di 
esecuzione inviati tramite Qiskit e recuperarne i risultati in un 
secondo momento. 

\section{Esempio di algoritmo}

Come rapido esempio dell'uso di Qiskit si propone il codice che riproduce 
l'algoritmo \ac{QKNN} presentato nella sezione \ref{sec:qknn}.

\begin{lstlisting}[float=h!,language=Python,frame=tb,caption={Algoritmo per il QKNN},label=lst:qknn]
    import qiskit.aqua.circuits.gates.controlled_ry_gates

    a = QuantumRegister(1,'a')
    m = QuantumRegister(1,'m')
    i = QuantumRegister(1,'i')
    c = QuantumRegister(1,'c')
    b = ClassicalRegister(2, 'bit')
    circuit = QuantumCircuit(a,m,i,c,b)

    circuit.h(a)
    circuit.h(m)

    circuit.cry(x0,a[0],i[0])
    circuit.x(a) # swap entanglement with ancilla to 0

    circuit.mcry(t0,a[:]+m[:],i[0],None)
    circuit.x(m) # swap entanglement with m index to 0

    circuit.mcry(t1,a[:]+m[:],i[0],None)

    circuit.cx(m,c) # entangle class 1 with m index 1

    circuit.h(a)
    circuit.measure(a,b[0])
    circuit.measure(c,b[1])

    # circuit.draw(output='mpl')
    \end{lstlisting}

    I valori x0, t0, t1 corrispondono agli angoli di rotazione per il vettore d'input e 
    per i due vettori di training rispettivamente. 
    La \marginpar{A partire dalla versione 0.12 di Qiskit la porta mcry è inclusa nei 
    pacchetti base e non c'è bisogno di importarla separtamente. 
    (Effettivamente tentarci comporta un errore nel programma.)}
    porta mcry non si trovava nelle funzioni di base di Qiskit ma è stata importata 
    separatamente attraverso il comando in cima. 
    Il disegno del circuito è presente in appendice nella figura A.1: si può notare 
    come le porte di rotazione controllata siano in realtà realizzate con una sequenza 
    di porte di base più o meno complicata. Tale processo è gestito automaticamente 
    da Qiskit. 